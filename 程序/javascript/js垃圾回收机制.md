**JavaScript 的垃圾回收机制**（Garbage Collection，GC）是自动内存管理的一部分，旨在清除程序中不再使用的对象和变量所占用的内存，以避免内存泄漏和提高性能。

---

### **核心概念**

1. **内存生命周期**：
    
    - **分配内存**：当声明变量、对象或函数时，JavaScript会自动分配内存。
    - **使用内存**：程序运行时对这些变量、对象或函数进行操作。
    - **释放内存**：当某些数据不再需要时，JS引擎会通过垃圾回收机制释放其内存。
2. **可达性**：
    
    - JS垃圾回收基于“可达性”（Reachability）的概念。
    - 一个值如果可以通过某种方式访问到，就被认为是“可达的”，这意味着它仍然需要被保留在内存中。
    
    **主要可达性的来源**：
    
    - 从全局对象（如 `window`）直接引用的对象。
    - 当前函数调用链上局部变量和参数。
    - 通过闭包或对象引用的变量。
3. **垃圾回收算法**：
    
    - **标记清除（Mark-and-Sweep）**：
        1. JS引擎会从根对象（如全局对象）出发，递归查找所有引用的对象。
        2. 被标记为可达的对象会保留。
        3. 没有被标记到的对象将被清除。
    - **引用计数（Reference Counting）**：
        - 每个对象被引用的次数会记录下来，引用数为0时，说明该对象不再被需要。
        - 这种方式容易导致 **循环引用** 问题，因此现代引擎通常不用单纯的引用计数。

---

### **垃圾回收的常见问题**
 
1. **内存泄漏**：
    
    - **意外的全局变量**：
        
        ```js
        function foo() {
            bar = "This is global"; // 忘记加 `var` 或 `let`
        }
        ```
        
    - **未清理的定时器或事件监听器**：
        
        ```js
        let obj = {};
        setInterval(() => {
            console.log(obj);
        }, 1000); // 即使 obj 不再使用，定时器仍然引用它
        ```
        
    - **闭包**： 如果闭包中不小心保存了不必要的引用，可能导致内存无法释放。
2. **循环引用**：
    
    - 引用计数无法处理如下场景：
        
        ```js
        let a = {};
        let b = {};
        a.b = b;
        b.a = a;
        ```
        
        两者互相引用，即使程序中没有其他地方再用到 `a` 和 `b`，它们仍然会占用内存。

---

### **如何避免内存问题**

1. **清理定时器或事件监听器**： 在不再需要时使用 `clearInterval` 或 `removeEventListener`。
    
2. **避免意外的全局变量**： 始终使用 `let` 或 `const` 声明变量。
    
3. **主动释放引用**： 当对象不再使用时，将其赋值为 `null`，方便垃圾回收机制回收内存。
    
    ```js
    let obj = { key: "value" };
    obj = null;
    ```
    
4. **减少循环引用**： 通过弱引用（如 `WeakMap`、`WeakSet`）避免循环引用问题。
    

---

### **常见工具**

- **浏览器开发工具**：
    - Chrome 开发者工具中的 **Memory** 标签，可以查看堆快照（Heap Snapshot）、分配时间线等，帮助检测内存泄漏。
- **代码工具**：
    - 使用 `console.memory` 查看内存使用情况。

---

**总结**：JavaScript 的垃圾回收机制大部分时候不需要开发者手动管理，但理解其工作原理有助于避免内存泄漏、优化性能和编写更高效的代码。
