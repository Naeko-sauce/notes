[---

## 🌐 一、什么是 GO（Global Object，全局对象）

### 1. 定义：

GO 是当 JavaScript 脚本开始执行时，最先创建的一个对象。它代表的是全局执行上下文中用于存储变量、函数声明的对象。

在浏览器中，GO 就是 `window` 对象；  
在 Node.js 中，GO 是 `global` 对象。

---

### 2. 作用：

- 存储全局作用域下的变量和函数。
    
- 是全局执行上下文中的“变量对象”。
    

---

### 3. 示例：

```javascript
var a = 10;
function foo() {}

console.log(window.a);   // 10
console.log(window.foo); // ƒ foo() {}
```

这里：

- `a` 和 `foo` 是在全局作用域中声明的；
    
- 实际上被存储在 `GO`（即浏览器中是 `window`）中。
    

---

## 🔁 二、什么是 AO（Activation Object，活动对象）

### 1. 定义：

AO 是在 **函数执行时创建的对象**，用于存储函数中的变量、函数声明、参数等，是**函数执行上下文中的变量对象**。

---

### 2. AO 的构建过程（面试重点）：

每当一个函数被调用时，都会生成一个 AO 对象，它经历以下几个步骤：

#### 💡 ① 创建 AO 对象

创建一个空对象 `{}`。

#### 💡 ② 添加 arguments 对象

把传入的实参和形参绑定到 `arguments` 中：

```javascript
function test(x, y) {}
test(10, 20);
```

会生成：

```javascript
AO = {
  arguments: {
    0: 10,
    1: 20,
    length: 2
  },
  x: 10,
  y: 20
}
```

#### 💡 ③ 函数声明提升（优先级高于变量）

将函数声明提前并存入 AO。

#### 💡 ④ 变量声明提升（不会赋值）

只提升声明，不提升赋值。

---

### 3. 示例详解：

```javascript
function fn(a) {
  console.log(a); // ƒ a() {}
  var a = 123;
  console.log(a); // 123
  function a() {}
  console.log(a); // 123
}

fn(1);
```

我们来一步步看 AO 对象的变化：

#### 💻 初始化 AO：

```js
AO = {
  arguments: {
    0: 1
  },
  a: 1
}
```

#### 🧠 函数声明提升（function a()）优先级高于参数：

```js
AO = {
  arguments: {
    0: 1
  },
  a: function a() {}
}
```

#### 🧠 var a = 123; 是变量提升，但赋值不提升：

```js
AO = {
  arguments: {
    0: 1
  },
  a: function a() {}  // 原本 function 覆盖了参数
}
// 后续执行 var a = 123 时，a 值被修改
```

最终：

```js
console.log(a); // function a() {}
var a = 123;
console.log(a); // 123
console.log(a); // 123
```

---

## ✅ 总结：GO 和 AO 对比

| 特性      | GO（全局对象）      | AO（活动对象）     |
| ------- | ------------- | ------------ |
| 存在时机    | 脚本执行前         | 每次函数调用时      |
| 存储内容    | 全局变量、全局函数     | 参数、局部变量、函数声明 |
| 生命周期    | 页面生命周期        | 函数调用到函数退出    |
| 示例对象    | `window`（浏览器） | 函数内部对象       |
| 执行上下文类型 | 全局执行上下文       | 函数执行上下文      |

---

如果你想深入学习 JS 执行机制，可以学习执行上下文栈（ECStack）、变量对象（VO）、作用域链等内容，GO 和 AO 是这其中的关键组成部分。

需要我帮你画图理解或者举更复杂的闭包/变量提升例子吗？](<当然可以，下面我用**非常通俗的语言**来详细解释 JavaScript 中的 `AO`（**活动对象**）和 `GO`（**全局对象**）的概念。我们从最基础的内容讲起，一步步带你搞懂它们是干嘛的、在哪用、怎么理解。

---

## 一、什么是 GO（Global Object，全局对象）？

### 白话理解：

你可以把 JavaScript 的**运行环境**想象成一个大房间，这个房间最开始什么也没有。但是，当 JavaScript 开始运行的时候，它就会**先创建一个“总管家”——全局对象（GO）**，这个总管家负责管理整个房间里一开始就能用的东西，比如：

* `window`（浏览器中就是这个）
* `console`
* 全局变量
* 全局函数（比如你写在最外层的函数）

---

### 举个例子：

```js
var a = 10;
function foo() {
  console.log('Hello');
}
```

这些 `a` 和 `foo()` 都是挂在 **GO（全局对象）** 上的。

在浏览器里你可以试试：

```js
console.log(window.a); // 10
console.log(window.foo); // ƒ foo() { ... }
```

所以，**全局作用域中声明的变量、函数，最终都会挂载到 GO 上**。

---

## 二、什么是 AO（Activation Object，活动对象）？

### 白话理解：

当你调用一个函数时，这个函数就像是一个“小屋子”，它自己也需要有一个“屋子里的管理者”来处理函数里的变量、参数、内部函数等，这个管理者就是 **AO 活动对象**。

每次函数执行的时候，都会临时创建一个 AO，用来存储这个函数内部的所有**变量、参数、函数声明**等信息。

---

### 举个例子：

```js
function test(x) {
  var y = 2;
  function bar() {}
}
test(5);
```

当你调用 `test(5)` 的时候，JS 引擎就会为 `test` 这个函数创建一个 AO，看起来像这样：

```
AO = {
  x: 5,         // 形参
  y: undefined, // 变量提升后是 undefined
  bar: function bar() {}
}
```

%3E 所以 AO 是**函数执行时的“内部作用域环境”**，只在函数执行过程中存在。

---

## 三、GO 和 AO 的区别和联系

| 对象 | 名称                     | 什么时候创建         | 存什么东西          | 生命周期         |
| -- | ---------------------- | -------------- | -------------- | ------------ |
| GO | Global Object 全局对象     | 页面加载或脚本执行开始时创建 | 全局变量、函数、内置对象   | 整个页面生命周期内都存在 |
| AO | Activation Object 活动对象 | 函数执行的时候创建      | 函数参数、局部变量、内部函数 | 函数执行完后就销毁    |

---

## 四、执行上下文（Execution Context）怎么和 GO/AO 关联？

当 JS 引擎执行代码时，它会为每一段代码创建一个 **执行上下文（EC）**，每个执行上下文都会绑定一个作用域对象：

* 全局执行上下文 ⇒ 绑定的是 GO
* 函数执行上下文 ⇒ 绑定的是 AO

你可以这样理解执行上下文的生成过程：

1. **全局阶段**：创建全局执行上下文

   * 生成 GO（挂载全局变量、函数）
2. **函数调用阶段**：为每个函数调用生成一个新的执行上下文

   * 创建 AO
   * AO 里存参数、局部变量、内部函数等

---

## 五、变量提升的奥秘：AO 的“预处理阶段”

JavaScript 函数在执行前会先进行**预处理**（变量提升），这个过程其实就是提前把变量和函数放进 AO 里，只是变量没有赋值，默认是 `undefined`。

### 举个更实际的例子：

```js
function demo(a) {
  console.log(a); // 1
  console.log(b); // undefined
  console.log(c); // ƒ c() {}
  
  var b = 2;
  function c() {}
}
demo(1);
```

执行时 AO 会先创建成这样：

```js
AO = {
  a: 1,            // 形参
  b: undefined,    // 变量声明提升
  c: function c() {} // 函数声明提升
}
```

所以，虽然 `b` 还没赋值，但不会报错；而 `c` 能直接使用，是因为函数声明提升。

---

## 六、一句话总结

* **GO 就是全局作用域的大管家**，页面加载时创建，包含所有全局变量和函数。
* **AO 是函数的“临时小账本”**，每次函数调用时创建，存储这个函数内部的变量和参数。
* **变量提升、作用域链、本质上都和 AO/GO 结构密切相关**。

---

如果你还想更深入，比如配合“作用域链”、“执行上下文栈”等继续深入分析我也可以继续讲。需要我画图或者结合调试过程讲解也可以说一声。>)](<当然可以！我们现在把 JavaScript 中的 `GO`（全局对象）、`AO`（活动对象）、`VO`（变量对象）这三个看起来很“抽象”的概念，**用非常通俗易懂的语言**详细地解释清楚。

---

## 一句话带你入门

**GO、AO、VO 是 JavaScript 引擎在执行代码时，背后偷偷做的一些事，用来“管理变量和函数”**，它们负责收纳你写的各种变量、函数、参数等等，就像是后台仓库、清单系统。

---

## 🧠 一、VO（变量对象，Variable Object）是什么？

### 白话解释：

你可以把 VO 想象成一个 **装变量的大盒子**，用来保存**函数里的变量、参数、函数声明**这些“数据”。

VO 并不是你写代码能直接看到的，而是**JS 引擎在执行代码时，在背后自动创建的**一个东西，用来管理作用域里的内容。

---

## 🧠 那 AO 和 GO 是不是 VO？

没错，**AO 和 GO 本质上就是 VO 在不同场景下的表现形式**：

| 名称  | 全称                      | 属于 VO 吗？ | 创建时机       | 管理什么            | 什么时候消失        |
| --- | ----------------------- | -------- | ---------- | --------------- | ------------- |
| GO  | Global Object（全局对象）     | ✅ 是 VO   | 页面加载/脚本运行时 | 全局变量、函数         | 页面关闭才消失       |
| AO  | Activation Object（活动对象） | ✅ 是 VO   | 函数被调用时     | 函数的参数、内部变量、函数声明 | 函数执行完就销毁      |
| VO  | Variable Object（变量对象）   | ✅ 抽象统称   | 每个执行上下文都有  | 抽象的总称           | 看情况（依附于执行上下文） |

也就是说：

%3E VO 是一个抽象的“变量收纳盒子”。
>
> * 在全局作用域中，这个盒子叫 GO。
> * 在函数作用域中，这个盒子叫 AO。

---

## 二、执行上下文和 VO 的关系

JavaScript 执行时，每段代码会进入一个“执行上下文”（Execution Context），可以理解为一张“运行环境的地图”。

每个执行上下文都有一个 **VO 变量对象**，JS 会在执行之前先准备这个 VO：

1. 把变量名都记下来（先设为 `undefined`）
2. 把函数名都放进去（直接变成完整函数）
3. 把参数也记进去（赋值实际传参）

这个过程就是所谓的 **变量提升**。

---

## 三、详细讲 AO：函数里的变量盒子

```js
function foo(x) {
  var y = 2;
  function bar() {}
}
foo(1);
```

当调用 `foo(1)` 的时候，会创建一个函数执行上下文，其中的 VO 被叫做 AO，初始化时会这样：

```js
AO = {
  x: 1,              // 参数 -> x = 1
  y: undefined,      // 变量提升，但未赋值
  bar: function bar() {}  // 函数提升
}
```

所以执行到 `var y = 2` 的时候，只是给 `y` 赋值了而已，`y` 这个变量早就被声明在 AO 里了。

---

## 四、详细讲 GO：全局变量的总管家

```js
var a = 10;
function hello() {
  console.log('hi');
}
```

这段代码在运行前，会创建一个全局执行上下文，其中的 VO 被称为 GO：

```js
GO = {
  a: 10,
  hello: function hello() {}
}
```

这些变量和函数会挂在浏览器里的 `window` 上：

```js
console.log(window.a);     // 10
console.log(window.hello); // function
```

所以我们说：**全局作用域的变量，最终都是 GO 的属性**。

---

## 五、VO 的初始化过程（变量提升的来源）

变量提升，就是因为 VO 的生成分为两个阶段：

### 1. 创建阶段（执行前）

JS 引擎做三件事：

* 找出所有变量声明（比如 `var`）
* 找出所有函数声明（不是函数表达式）
* 记录参数名和传入值

此时值都还没赋，变量设为 `undefined`，函数是完整定义。

### 2. 执行阶段（开始执行代码）

这时候变量才会赋值，函数才会真正执行。

---

## 六、总结归纳图 🧠

```
┌─────────────┐
│ 执行上下文  │
└─────────────┘
       ↓
┌─────────────────────┐
│ 变量对象 VO          │ ← 抽象盒子，用于存变量/函数
├─────────────────────┤
│ 如果是全局：叫 GO    │ ← window.xxx
│ 如果是函数：叫 AO    │ ← 每次函数执行新建一个
└─────────────────────┘
```

---

## ✅ 最后举个综合例子理解

```js
var a = 1;
function test(b) {
  var c = 2;
  function inner() {
    var d = 3;
    console.log(a, b, c, d);
  }
  inner();
}
test(10);
```

执行流程如下：

* 创建 GO（全局 VO）：

  ```js
  GO = {
    a: 1,
    test: function
  }
  ```

* 执行 `test(10)`：
  创建 AO：

  ```js
  AO = {
    b: 10,     // 参数
    c: undefined,
    inner: function
  }
  ```

* 执行 `inner()`：
  创建 AO：

  ```js
  AO = {
    d: undefined
  }
  ```

然后 `d = 3`，赋值完之后才能打印。

---

## 总结一句话：

* **VO 是“变量的抽象容器”，用来收纳变量和函数，是作用域的核心。**
* **在全局作用域里，这个容器叫 GO，全局变量都会放进去。**
* **在函数作用域里，这个容器叫 AO，专门存函数内部的数据。**
* **变量提升和作用域链，就是基于 VO / AO / GO 来实现的。**

---

如果你还不太理解，可以告诉我你是哪一步不懂，我可以用“图 + 动画 + 对比”再深入拆解。需要我画图或再出几个练习题也可以！>)