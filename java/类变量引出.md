## final

* final的意思是最后的，最终的

* final可以修饰类，属性，方法，和局部变量

* 在某些情况下，就会使用到final

  > * 当不希望类被继承时，可以用final修饰
  > * 当不希望父类的某个方法被子类覆盖，重写时，可以使用final关键字
  > * 当不希望类的某个属性值被修改，可以使用final
  > * 当不希望某个局部变量被修改，可以使用final

## 抽象类

* 抽象类的介绍

* 用abstract关键字来修饰一个类时，这个类就叫抽象类

* 用abstract关键字来修饰一个方法时这个方法就是抽象方法，访问修饰符abstract返回类型方法名（参数列表）//没有方法体

* 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类

## 内部类

* 局部类部类

  > 局部类部类是定义在外部类的局部位置，比如方法中，并且有类名
  >
  > 不能添加访问修饰符，因为他的地位就是一个局部变量，局部变量是不能使用，修饰符的，但是可以使用final修饰，因为局部变量也可以使用final
  >
  > 局部内部内-》访问-》外部类的成员，直接访问
  >
  > 外部类-》访问-》局部内的成员，先创建对象，在访问

* 匿名内部类

  > 本质是类，同时还是一个对象
  >
  > 内部类
  >
  > 该类没有名字
  >
  > 匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名
  >
  > 匿名内部类的语法比较奇特，因为匿名内部类既是一个类的定义，同时他本身也是一个对象，因此从语法上看，他既有定义类的特征，也有创建对象的特征

* 成员内部类

  > 成员内部类是定义在外部类的成员位置，并且没有static修饰，可以直接访问外部类的所有成员

* 静态内部类

  > 静态内部类定义在外部类的成员位置，并且有static修饰
  >
  > 可以直接访问外部类的所有静态成员，但不能直接访问非静态成员

## 枚举

* 自定义枚举

  > 枚举是一组常量的集合

  > 枚举属于一种特殊的类，里面只包含一组有限的特定的对象

  > 不需要提供set方法，因为枚举对象通常为只读
  >
  > 对枚举对象/属性使用final+static共同修饰，实现底层优化
  >
  > 枚举对象名通常使用大写
  >
  > `将构造器私有化，本类创建一组对象。对外暴露对象。通过为对象添加public final static修饰符可以提供get方法，但是不提供set方法`

* enum枚举

  >```java
  >package com.jbn;
  >
  >public class emmj {
  >    public static void main(String[] args) {
  >        System.out.println(lm.Ct);
  >    }
  >}
  >enum lm{
  >//    使用enum关键字代替class
  >//    常量名(实参列表)如果有多个对象使用逗号隔开
  >    //如果使用enum来实现枚举，要求将定义常量对象，写在前面
  >    Ct("春天","温暖"),Qt("秋天","凉爽");
  >    private String xm;
  >    private String sx;
  >
  >    private lm(String xm, String sx) {
  >        this.xm = xm;
  >        this.sx = sx;
  >    }
  >
  >    public String getXm() {
  >        return xm;
  >    }
  >
  >    public String getSx() {
  >        return sx;
  >    }
  >
  >    @Override
  >    public String toString() {
  >        return "ne{" +
  >                "xm='" + xm + '\'' +
  >                ", sx='" + sx + '\'' +
  >                '}';
  >    }
  >}
  >```
  >
  >```java
  >package com.jbn;
  >
  >public class emmj {
  >    public static void main(String[] args) {
  >        System.out.println(lm.Ct);
  >        lm a = lm.Ct;
  >        //输出枚举对象的名字
  >        System.out.println(a.name());
  >        //输出枚举对象的次序，从零开始
  >        System.out.println(a.ordinal());
  >        //以数组的形式取出枚举
  >       lm[] d = lm.values();
  >       //增强for循环
  >       for (lm s :d){
  >           System.out.println(s);
  >       }
  >       //根据你输入的名字到lm枚举对象中查找，如果找到了就返回，没找到就报错
  >       lm ad = lm.valueOf("Ct");
  >        System.out.println(ad);
  >    }
  >}
  >enum lm{
  >//    使用enum关键字代替class
  >//    常量名(实参列表)如果有多个对象使用逗号隔开
  >    //如果使用enum来实现枚举，要求将定义常量对象，写在前面
  >    Ct("春天","温暖"),Qt("秋天","凉爽");
  >    private String xm;
  >    private String sx;
  >
  >    private lm(String xm, String sx) {
  >        this.xm = xm;
  >        this.sx = sx;
  >    }
  >
  >    public String getXm() {
  >        return xm;
  >    }
  >
  >    public String getSx() {
  >        return sx;
  >    }
  >
  >    @Override
  >    public String toString() {
  >        return "ne{" +
  >                "xm='" + xm + '\'' +
  >                ", sx='" + sx + '\'' +
  >                '}';
  >    }
  >}
  >```
  >
  >

## 注解

* 注解（annotation）也被称为元数据，用于修饰解释 包，类，方法，属性，构造器，局部变量等数据信息

* 和注释一样，注释不影响程序逻辑，但注解可以被编译或者运行，相当于嵌入在代码中的补充信息

* 在Javase中，注解的使用目的比较简单，列如标记过时的功能，在javaee中注解用来配置应用程序的任何切面等。

* 使用annotation时要在前面增加@符号，并把annotation当成一个修饰符使用

* 三个基本的annotation

  > @Override：限定某个方法，是重写父类方法，该注解只能用于方法
  >
  > @Deprecated：用于表示某个程序元素，类，方法等已过时
  >
  > @Suppress Warnings：抑制编译器警告

## 异常

* 在Java中，将程序执行中发生的不正常情况称为异常。

* 执行过程中所发生的异常事件可分为两类

  > Error(错误)：Java虚拟机无法解决的严重问题，如jvm系统内部错误，资源耗尽等严重情况
  >
  > Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理

## String Buffer类

* 基本介绍

  > Java.lang.StingBuffer代表可变的字符序列，可以对字符串内容进行曾删，很多方法与Sting相同 Sting Buffer是可以变长度的
  >
  > StringBuffer是一个容器。
  >
  > String Buffer的直接父类 是ABstract String Builder
  >
  > String Buffer实现了 Serializable，即Sting Buffer的对象可以串行化  
  >
  > 在父类中 ABstract String Builder有char[] value，不是final该value数组存放字符串内容，引出存放在堆中的
  >
  > Sting Buffer 是一个final类，不能被继承
  >
  > Sting保存的是字符串常量，里面的值不能更改，每次Sting类的更新实际上就是更改地址，效率较低private final char value[];
  >
  > Sting Buffer保存的是字符串变量，里面的值可以更改，每次Sting Buffer的更新实际上可以更新内容，不用更新地址，效率较高，放在char[] value这个堆
  >
  > ```java
  > package com.zx;
  > 
  > public class Stbf {
  >     public static void main(String[] args) {
  >         //创建一个大小为16的char[]，用于存放字符内容
  >         StringBuffer ds = new StringBuffer();
  >         //通过构造器指定char[]大小
  >         StringBuffer ds1 =new StringBuffer(100);
  >         //通过给一个Sting创建Sting Buffer,char[]大小就是你当前字符串加16长度
  >         StringBuffer dsi = new StringBuffer("hool");
  >     }
  > }
  > 
  > ```
  >

## String Builder类

* 基本介绍

  > 一个可变的字符序列。此类提供一个与String Buffer兼容的API，但不保证同步，该类被设计作用String Buffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候，建议先采用Sting Builder，因为在大多数实现中，他比StingBuffer要快
  >
  > 在String Buffer上的主要操作是append和insert方法，可重载这些方法以接受任意类型的数据

* 比较

  > String Buffer和String Builder非常类似，均代表可变的字符序列，而且方法也一样
  >
  > String：不可变字符序列，效率低，但是复用率高
  >
  > String Buffer：可变字符序列，效率较高（增删），线程安全
  >
  > String Builder：可变字符序列，效率高，线程不安全

* String使用注意

  > String s = "a";//创建了一个字符串
  >
  > s += "b";//实际上原来的a字符串对象已经丢弃了，现在又产生了一个字符串s+"b"(也就是ab)。如果多次执行这些改变字符串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率，如果这样的操作放到循环中，会极大的影响程序的性能：如果要对String做大量的修改，不要使用String
  >
  > 